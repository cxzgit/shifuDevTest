XYZ-1000 Smart Sensor HTTP Driver (Modbus RTU over RS485)

Overview
- This driver connects to the XYZ-1000 Smart Sensor via Modbus RTU over an RS485 serial interface and exposes a minimal HTTP API.
- It actively polls the device for measurement and status once per second and serves the latest sample.
- It supports initialization, automatic reconnection with exponential backoff, and runtime reconfiguration of baud rate and device address.

Requirements
- Golang 1.21+
- RS485/serial port available on the host, wired to the device

Environment Variables
- IOT_HTTP_HOST: Host interface for HTTP server (default: 0.0.0.0)
- IOT_HTTP_PORT: Port for HTTP server (default: 8080)
- IOT_SERIAL_PORT: Serial/RS485 port (e.g., /dev/ttyUSB0, COM3)
- IOT_BAUD_RATE: Modbus RTU baud rate (9600–115200; default: 9600)
- IOT_MODBUS_ADDRESS: Modbus device address/node (1–247; default: 1)
- IOT_POLL_INTERVAL_MS: Polling interval in milliseconds (default: 1000)
- IOT_READ_TIMEOUT_MS: Per-request read timeout in milliseconds (default: 500)
- IOT_RETRY_INITIAL_MS: Initial retry backoff delay in milliseconds (default: 500)
- IOT_RETRY_MAX_MS: Maximum retry/backoff delay in milliseconds (default: 10000)

Build & Run
1) Set environment variables as appropriate, for example:
   export IOT_SERIAL_PORT=/dev/ttyUSB0
   export IOT_BAUD_RATE=9600
   export IOT_MODBUS_ADDRESS=1
   export IOT_HTTP_PORT=8080

2) Build:
   go build -o driver

3) Run:
   ./driver

HTTP API Endpoints
- POST /connect
  Initialize the driver and start communication. Optionally override port, baud_rate, device_address in the JSON body.
  Request body example:
  {"port":"/dev/ttyUSB0","baud_rate":9600,"device_address":1}
  Responses:
  - 200 {"status":"connected"}
  - 202 {"status":"reconnecting"} (auto-retry in progress)
  - 400 for invalid parameters
  - 409 if the serial port is already in use/busy
  - 504 on connection timeout

  Quick test:
  curl -X POST http://localhost:8080/connect -H 'Content-Type: application/json' -d '{"port":"/dev/ttyUSB0","baud_rate":9600,"device_address":1}'

- PUT /config
  Idempotently set communication parameters (baud_rate, device_address). Applies safely; may trigger reconnect.
  Request body examples:
  {"baud_rate":115200}
  {"device_address":7}
  Responses:
  - 200 {"status":"applied"} when no reconnect needed
  - 202 {"status":"reconnecting"} when changes require reopening the link
  - 400 for invalid values

  Quick test:
  curl -X PUT http://localhost:8080/config -H 'Content-Type: application/json' -d '{"baud_rate":19200}'

- GET /measurement
  Retrieve the latest measurement value with timestamp.
  Responses:
  - 200 {"value":<number>,"timestamp":"<RFC3339>"}
  - 503 if not connected
  - 504 if device timeout detected
  - 502 if an invalid/corrupted Modbus response was detected

  Quick test:
  curl http://localhost:8080/measurement

- GET /status
  Retrieve driver and device communication status.
  Response fields:
  - connection_state (connected/reconnecting/disconnected)
  - port, baud_rate, device_address
  - last_seen, retry_count, last_error
  - device_status_raw (raw status register value)

  Quick test:
  curl http://localhost:8080/status

Notes
- Data format: JSON
- Serial framing: 8N1 (8 data bits, no parity, 1 stop bit)
- The driver performs background polling every IOT_POLL_INTERVAL_MS and maintains a thread-safe buffer of the latest sample.
- On errors, the driver retries with exponential backoff until reconnection.
- Graceful shutdown supported via SIGINT/SIGTERM.

Generated by [IoT Driver Copilot](https://copilot.test.shifu.dev/)
