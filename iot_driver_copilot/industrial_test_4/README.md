Industrial test4 Modbus RTU -> HTTP Driver (Python)

This driver connects to an industrial environmental sensor over Modbus RTU (RS-485, 9600 8N1) and exposes a minimal HTTP API to manage the connection and retrieve current status plus latest sensor readings (temperature, humidity, CO₂). The driver actively polls the sensor via Modbus function code 0x03 (Read Holding Registers) and maintains a thread-safe buffer for fast HTTP responses.

Endpoints (only these are implemented)
- POST /connect
  - Open the RS-485 serial connection to the Modbus RTU sensor.
  - Body JSON: { "port": "/dev/ttyUSB0" | "COM3", "slave_id": 1-247 }
  - If already connected to the same port and slave, this is a no-op; otherwise the link is reinitialized.
- GET /status
  - Returns connection and polling status and the latest sample.
  - Example fields: connected, port, slave_id, poll.enabled, poll.interval_ms, last_read_at, last_error, sample.temperature, sample.humidity, sample.co2.

Configuration via environment variables
All configuration must be provided through environment variables. No hard-coded configuration values are used.

Required
- HTTP_HOST: HTTP server bind host (e.g., 0.0.0.0)
- HTTP_PORT: HTTP server port (e.g., 8080)
- MODBUS_TIMEOUT_MS: Serial read timeout in milliseconds (e.g., 500)
- POLL_INTERVAL_MS: Polling interval in milliseconds (e.g., 1000)
- BACKOFF_INITIAL_MS: Initial backoff in milliseconds after failures (e.g., 1000)
- BACKOFF_MAX_MS: Maximum backoff in milliseconds (e.g., 10000)
- RETRY_MAX: Number of immediate retry attempts per poll cycle before backoff (e.g., 3)
- REG_TEMP_ADDR: Holding register address for temperature (0-65535)
- REG_HUM_ADDR: Holding register address for humidity (0-65535)
- REG_CO2_ADDR: Holding register address for CO₂ (0-65535)

Optional
- MODBUS_PORT: Serial port path (e.g., /dev/ttyUSB0 or COM3). Can alternatively be provided in POST /connect.
- MODBUS_SLAVE_ID: Modbus slave ID (1-247). Can alternatively be provided in POST /connect.
- REG_TEMP_SCALE: Optional numeric scaling factor for temperature (applied as value = raw * scale)
- REG_HUM_SCALE: Optional numeric scaling factor for humidity (applied as value = raw * scale)
- REG_CO2_SCALE: Optional numeric scaling factor for CO₂ (applied as value = raw * scale)

Notes
- The device link is opened at 9600 baud, 8 data bits, no parity, 1 stop bit (8N1) as required by the device specification.
- Function code 0x03 is used to read holding registers.
- The driver polls three individual 16-bit registers (temperature, humidity, CO₂). If your device uses different register mappings or data widths/scales, set the appropriate addresses and scaling factors accordingly.

Install dependencies
- Python 3.9+
- pyserial

Install:
  pip install pyserial

Run
Example (Linux):
  export HTTP_HOST=0.0.0.0
  export HTTP_PORT=8080
  export MODBUS_TIMEOUT_MS=500
  export POLL_INTERVAL_MS=1000
  export BACKOFF_INITIAL_MS=1000
  export BACKOFF_MAX_MS=10000
  export RETRY_MAX=3
  export REG_TEMP_ADDR=0
  export REG_HUM_ADDR=1
  export REG_CO2_ADDR=2
  python3 driver.py

Connect to the device (example on Linux):
  curl -sS -X POST http://localhost:8080/connect \
    -H 'Content-Type: application/json' \
    -d '{"port":"/dev/ttyUSB0","slave_id":1}' | jq

Check status:
  curl -sS http://localhost:8080/status | jq

Status response example
{
  "connected": true,
  "port": "/dev/ttyUSB0",
  "slave_id": 1,
  "baud": 9600,
  "parity": "N",
  "stopbits": 1,
  "poll": {"enabled": true, "interval_ms": 1000},
  "last_read_at": "2025-01-01T12:00:00+0000",
  "last_error": null,
  "sample": {
    "temperature": 23.4,
    "humidity": 45.8,
    "co2": 550,
    "raw": {"temperature": 234, "humidity": 458, "co2": 550},
    "timestamp": "2025-01-01T12:00:00+0000"
  }
}

Graceful shutdown
Press Ctrl+C or send SIGTERM. The driver stops the background poller and closes the serial port cleanly.

Security considerations
- The HTTP server binds to HTTP_HOST and port provided. Ensure proper network isolation when binding to 0.0.0.0.
- No credentials or authentication are implemented; deploy behind a secure gateway if needed.

Generated by [IoT Driver Copilot](https://copilot.test.shifu.dev/)
